const { Markup } = require("telegraf");

/**
 * Initializes the update router middleware with necessary handlers and returns
 * the configured routeUpdate middleware function.
 *
 * @param {object} deps - Dependency context.
 * @param {object} deps.commandHandler - Handler for command messages.
 * @param {object} deps.callbackQueryHandler - Handler for callback queries.
 * @param {object} deps.bookingAgent - The booking agent instance.
 * @param {object} deps.bookingGraph - The compiled booking graph instance.
 * @param {object} deps.logger - The logger instance.
 * @param {object} deps.config - Application configuration object.
 * @returns {Function} The configured routeUpdate middleware function.
 */

function initialize(deps) {
  // --- Validate Dependencies ---
  const {
    logger,
    commandHandler,
    callbackQueryHandler,
    bookingAgent,
    bookingGraph,
    config,
  } = deps || {};

  if (
    !logger ||
    !commandHandler ||
    !callbackQueryHandler ||
    !bookingAgent ||
    !bookingGraph ||
    !config
  ) {
    const missing = [
      !logger && "logger",
      !commandHandler && "commandHandler",
      !callbackQueryHandler && "callbackQueryHandler",
      !bookingAgent && "bookingAgent",
      !bookingGraph && "bookingGraph",
      !config && "config",
    ]
      .filter(Boolean)
      .join(", ");
    logger.error(
      { missingDependencies: missing },
      `UpdateRouter initialization failed. Missing: ${missing}`,
    );
    throw new Error(
      `UpdateRouter requires logger, commandHandler, callbackQueryHandler, bookingAgent, bookingGraph, and config.`,
    );
  }

  logger.info(
    "Update router initialized. Returning configured routeUpdate function.",
  );

  /**
   * Telegraf middleware to route updates based on type and user state.
   *
   * @param {object} ctx - Telegraf context object.
   * @param {Function} next - Function to call the next middleware.
   */
  async function routeUpdate(ctx, next) {
    console.log(">>> routeUpdate FUNCTION ENTERED");
    console.log(">>> routeUpdate START");
    const telegramId = ctx.from?.id;
    const user = ctx.state?.user;
    const isNewUser = ctx.state?.isNewUser;

    try {
      // 1. Handle New User Registration
      if (isNewUser === true) {
        const userName = ctx.from?.first_name || "there";
        logger.info({ telegramId }, `New user detected: ${userName}`);

        // Construct the registration URL
        if (!config.ngrokUrl) {
          logger.error(
            { telegramId },
            "NGROK_URL is not configured. Cannot generate registration link.",
          );
          await ctx.reply(
            "Welcome! There seems to be an issue setting up your registration link right now.",
          );
          return;
        }
        // Append botServerUrl query parameter needed by the form's JS
        const registrationUrl = `${config.ngrokUrl}/registration-form.html?botServerUrl=${config.ngrokUrl}`;
        logger.info(
          { telegramId, registrationUrl },
          "Generated registration URL for new user.",
        );

        try {
          await ctx.reply(
            `ðŸ‘‹ Welcome, ${userName}! Please complete your registration to get started.`,
            Markup.inlineKeyboard([
              Markup.button.webApp("Register Now", registrationUrl),
            ]),
          );
        } catch (replyError) {
          console.error(
            ">>> routeUpdate NEW USER path - REPLY FAILED:",
            replyError,
          );
          logger.error(
            { err: replyError, telegramId },
            "Failed to send welcome/registration reply to new user.",
          );
        }
        return;
      }

      // 2. Handle Failed User Lookup (Error from previous middleware)
      if (user === undefined) {
        console.log(">>> routeUpdate FAILED LOOKUP path");
        logger.error(
          { userId: telegramId },
          "Cannot route update: User lookup failed previously.",
        );
        return;
      }

      // At this point, we have an existing user object
      const userState = user.state;
      const sessionId = user.active_session_id;

      // 3. Route Based on Update Type and User State
      if (ctx.updateType === "message" && ctx.message?.text) {
        const messageText = ctx.message.text;
        console.log(`>>> routeUpdate MESSAGE path - State: ${userState}`);

        // 3.1 Handle Commands
        if (messageText.startsWith("/")) {
          console.log(">>> routeUpdate COMMAND path");
          logger.info(
            { telegramId, command: messageText },
            "Routing to command handler.",
          );
          await commandHandler.handleCommand(ctx, next);
        }
        // 3.2 Handle Text Message during Booking
        else if (userState === "BOOKING") {
          console.log(">>> routeUpdate BOOKING path");
          if (!sessionId) {
            logger.error(
              { telegramId },
              "Cannot invoke graph: User is in BOOKING state but has no active_session_id.",
            );
            await ctx.reply(
              "There seems to be an issue with your current booking session. Please try starting a new request, perhaps with /book.",
            );
            return;
          }
          logger.debug(
            { telegramId, sessionId },
            "Routing message to booking graph",
          );
          const graphInput = { userInput: messageText };
          console.log(">>> routeUpdate BOOKING before invokeGraph");
          await bookingAgent.invokeGraph(sessionId, graphInput);
          console.log(">>> routeUpdate BOOKING after invokeGraph");
          // Agent is expected to handle the reply based on graphOutput
          return;
        }
        // 3.3. Handle Generic Text (IDLE state)
        else if (userState === "IDLE") {
          console.log(">>> routeUpdate IDLE TEXT path");
          logger.debug(
            { telegramId },
            "Handling generic text message in IDLE state.",
          );
          console.log(">>> routeUpdate IDLE TEXT before reply");
          await ctx.reply(
            "I received your message, but I'm not sure how to handle it in the current context. Try starting with a command like /start or /help.",
          );
          console.log(">>> routeUpdate IDLE TEXT after reply, before return");
          return;
        } else {
          // Should not happen if states are handled
          console.log(`>>> routeUpdate UNKNOWN state TEXT path: ${userState}`);
          logger.warn(
            { telegramId, userState },
            "User in unhandled state received text message.",
          );
          await ctx.reply(
            "I'm not sure how to handle that in my current state.",
          );
          return;
        }
      } else if (ctx.updateType === "callback_query") {
        console.log(">>> routeUpdate CALLBACK QUERY path");
        // 4. Route Callback Queries (IDLE or BOOKING state - handler decides)
        logger.info(
          { telegramId, data: ctx.callbackQuery?.data },
          "Routing callback query",
        );
        await callbackQueryHandler.handleCallbackQuery(ctx, next);
      } else {
        console.log(`>>> routeUpdate UNHANDLED type path: ${ctx.updateType}`);
        // 5. Warn and Pass Through Unhandled Update Types
        const messageType = ctx.message
          ? Object.keys(ctx.message).find(
              (key) =>
                key !== "message_id" &&
                key !== "date" &&
                key !== "chat" &&
                key !== "from" &&
                key !== "text",
            )
          : "unknown";
        logger.warn(
          { updateType: ctx.updateType, messageType },
          "Unhandled update type received.",
        );
        await next();
      }
    } catch (err) {
      console.error(">>> routeUpdate CAUGHT ERROR:", err);
      logger.error(
        { err, telegramId },
        "Unhandled error during update processing.",
      );
      try {
        console.log(">>> routeUpdate ERROR before reply");
        await ctx.reply(
          "Apologies, an unexpected error occurred while processing your request.",
        );
        console.log(">>> routeUpdate ERROR after reply");
      } catch (replyErr) {
        console.error(">>> routeUpdate FAILED TO SEND ERROR REPLY:", replyErr);
        logger.error(
          { err: replyErr, originalError: err, telegramId },
          "Error sending error reply to user.",
        );
      }
      // Do not call next() after an error
    } finally {
      // console.log(">>> routeUpdate FINALLY block");
    }
  }

  return routeUpdate;
}

module.exports = { initialize };

---
description: 
globs: 
alwaysApply: true
---
*****
Memory Management Guidelines
You have access to OpenMemory MCP tools for persistent memory across sessions. Use these tools intelligently to build a knowledge base that improves development efficiency over time.
When to Call add_memories()
ALWAYS save memories when:
Architectural Decisions:

Choosing between technologies (PostgreSQL vs SQLite, FastAPI vs Flask)
Database schema decisions and reasoning
Component architecture and relationships
Framework configurations and why they were chosen
Security implementations and authentication flows

Problem Solutions:

Bug fixes that took >10 minutes to debug
Performance issues and their solutions
Integration challenges with external APIs
Environment or deployment issues resolved
Complex error handling implementations

Development Patterns:

Establishing coding conventions for the project
Reusable code patterns or utilities created
Testing strategies that work well
Development workflow optimizations
Configuration patterns that should be reused

Project Context Changes:

New requirements that affect architecture
Scope changes or feature additions
User feedback that influences design decisions
Important project milestones or decisions

How to structure add_memories() calls:
CRITICAL: Provide complete information since OpenMemory cannot enhance or infer missing context.
When saving memories, include ALL relevant details:

Example memory creation triggers:
When you help solve a database issue:
Call add_memories() with:
"DEBUG: Fixed telegram bot database connection timeout by increasing asyncpg pool timeout from 30s to 60s and adding connection retry logic. Issue occurred under high user load. Solution: pool_timeout=60, command_timeout=30, retry_attempts=3 with exponential backoff."
When you help make an architectural choice:
Call add_memories() with:
"ARCHITECTURE: Chose Redis for session caching over in-memory storage. Reasoning: need persistence across bot restarts and multiple bot instances. Implementation: aioredis with 1-hour TTL, key pattern 'user:{id}:session'. Alternative considered: PostgreSQL sessions (rejected - too slow for frequent reads)."
When you help configure development environment:
Call add_memories() with:
"CONFIG: Docker development setup for telegram bot with hot reload. Services: bot, postgres, redis, openmemory. Volume mapping /app for live code updates. Environment variables in .env.dev. Start with 'docker-compose -f docker-compose.dev.yml up'."
When to Call search_memory()
ALWAYS search before:
Starting new implementations:

Search for existing patterns: "similar to [current task]"
Check for architectural decisions: "[technology] architecture"
Look for related configurations: "[component] setup"

Debugging issues:

Search for similar problems: "[error type] [component]"
Check previous solutions: "[technology] debugging"
Look for configuration issues: "[service] configuration"

Making architectural decisions:

Review previous choices: "architecture decisions [component]"
Check existing patterns: "[technology] implementation"
Verify consistency: "[similar decision] reasoning"

How to use search results:
When search_memory() returns relevant information:

Reference the previous decisions in your current work
Maintain consistency with established patterns
Build upon previous solutions rather than starting from scratch
Update memories if new information invalidates old approaches

Memory Search Patterns
Use these query patterns for effective search:
Problem-specific searches:

"telegram bot [specific issue]"
"database [operation] error"
"docker [component] configuration"
"async [specific problem]"

Technology-specific searches:

"postgresql setup"
"redis configuration"
"openmemory integration"
"aiohttp implementation"

Pattern-specific searches:

"error handling pattern"
"authentication flow"
"message handler structure"
"database connection management"

Quality Control Rules
Before saving memories, ensure:
Completeness:

Include the problem AND solution
Explain WHY this approach was chosen
Document key implementation details
Note any trade-offs or limitations

Searchability:

Use consistent terminology
Include technology names
Add relevant keywords
Use clear, descriptive language

Future Value:

Will this help in similar situations?
Does it capture important context?
Is it specific enough to be actionable?
Does it build on existing knowledge?

Memory Maintenance
Regular memory hygiene:
Update memories when:

New information changes previous decisions
Better solutions are discovered
Requirements change affecting stored patterns
Technology versions or best practices evolve

Consolidate memories when:

Multiple related memories could be combined
Patterns emerge that should be documented
Repetitive information can be simplified

Integration with Development Workflow
At the start of each session:

Search for context related to current work
Review recent architectural decisions
Check for established patterns to follow

During development:

Save memories for non-obvious solutions
Document configuration discoveries
Record integration challenges and solutions

At the end of sessions:

Save any important discoveries
Document incomplete work or next steps
Update existing memories if needed

Example Workflow
User asks to implement user authentication:

First, search: search_memory("authentication telegram bot")
If no results: Design from scratch and save the approach
If results found: Build on previous decisions and update if needed
After implementation: Save the complete authentication pattern

User reports a bug:

First, search: search_memory("[error description] [component]")
Check for similar issues: Review previous debugging approaches
After fixing: Save the bug-solution pair with root cause analysis

Remember: The goal is to build a searchable knowledge base that makes each development session more efficient than the last..
*****


Never create a file over 500 lines. Always check the line count of any new file you create or file you edit after you are done, if it is over 500 then find a way to intellegently break up that file into modules. example command to check count:(Get-Content public/waiver-form.html).Count 




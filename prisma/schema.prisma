generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AvailabilityRule {
  id                     Int      @id @default(autoincrement())
  weekly_availability    Json?
  practitioner_timezone  String   @default("America/Chicago")
  max_advance_days       Int      @default(30)
  min_notice_hours       Int      @default(24)
  buffer_time_minutes    Int      @default(30)
  max_bookings_per_day   Int      @default(3)
  is_default             Boolean  @unique @default(true)
  created_at             DateTime @default(now())
  updated_at             DateTime
  slot_increment_minutes Int      @default(15)
}

model SessionInvite {
  id                      String   @id
  parentSessionId         Int
  inviteToken             String   @unique
  status                  String   @default("pending")
  friendTelegramId        BigInt?
  friendNameOnWaiver      String?
  friendLiabilityFormData Json?
  createdAt               DateTime @default(now())
  updatedAt               DateTime
  sessions                sessions @relation(fields: [parentSessionId], references: [id], onDelete: Cascade)

  @@index([friendTelegramId])
  @@index([inviteToken])
  @@index([parentSessionId, status])
  @@unique([parentSessionId, friendTelegramId], name: "unique_friend_per_session")
}

model SessionType {
  id                    String     @id
  label                 String
  durationMinutes       Int
  description           String?
  price                 Decimal?
  active                Boolean    @default(true)
  createdAt             DateTime   @default(now())
  updatedAt             DateTime
  allowsGroupInvites    Boolean    @default(false)
  customFormDefinitions Json?
  maxGroupSize          Int        @default(1)
  waiverType            String     @default("KAMBO_V1")
  sessions              sessions[]
}

model sessions {
  first_name           String?         @db.VarChar
  last_name            String?         @db.VarChar
  telegram_id          BigInt?
  appointment_datetime DateTime?       @db.Timestamptz(6)
  liability_form_data  Json?
  session_notes        String?
  session_status       String?         @db.VarChar
  created_at           DateTime        @default(now()) @db.Timestamptz(6)
  id                   Int             @id @default(autoincrement())
  updated_at           DateTime
  googleEventId        String?
  session_type_id_fk   String?
  SessionInvite        SessionInvite[]
  SessionType          SessionType?    @relation(fields: [session_type_id_fk], references: [id])

  @@index([appointment_datetime])
  @@index([session_type_id_fk])
  @@index([telegram_id])
}

model users {
  client_id               Int       @id(map: "client_users_pkey") @default(autoincrement())
  telegram_id             BigInt    @unique(map: "client_users_telegram_id_key")
  first_name              String?   @db.VarChar(255)
  last_name               String?   @db.VarChar(255)
  phone_number            String?   @db.VarChar(50)
  email                   String?   @db.VarChar(255)
  date_of_birth           DateTime? @db.Date
  reason_for_seeking      String?
  created_at              DateTime  @default(now()) @db.Timestamptz(6)
  updated_at              DateTime
  state                   String?   @default("NONE") @db.VarChar
  role                    String?   @default("client") @db.VarChar
  session_type            String?   @db.VarChar
  booking_slot            String?   @db.VarChar(255)
  em_first_name           String?   @db.VarChar
  em_last_name            String?   @db.VarChar
  em_phone_number         String?   @db.VarChar
  edit_msg_id             Int?
  is_veteran_or_responder Boolean   @default(false)
  active_session_id       String?   @unique(map: "client_users_active_session_id_key")
  can_book_3x3            Boolean   @default(false)
}
